#include <algorithm>
#include <fstream>
#include <iostream>
#include <regex>
#include <string>
#include <vector>

#include "map_reduce/protocol.h"

namespace mapReduce {
//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
std::vector<KeyVal> Map(const std::string &content) {
  // Your code goes here
  // Hints: split contents into an array of words.
  std::vector<KeyVal> ret;

  // Split the content into words, using regex because :-) is not considered
  // part of a word
  std::regex words_regex("[a-zA-Z]+");
  auto words_begin =
      std::sregex_iterator(content.begin(), content.end(), words_regex);
  auto words_end = std::sregex_iterator();

  // Count the number of occurrences of each word
  std::map<std::string, u32> word_count;
  for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
    std::smatch match = *i;
    std::string word = match.str();
    word_count[word]++;
  }

  // Add the word count to the return vector
  for (auto &pair : word_count) {
    ret.push_back(KeyVal(pair.first, pair.second));
  }

  return ret;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
std::vector<KeyVal> Reduce(std::vector<std::vector<KeyVal>> &key_val) {
  // Your code goes here
  // Hints: return the number of occurrences of the word.
  std::vector<KeyVal> reduced;
  for (auto &vec : key_val) {

    for (auto &keyVal : vec) {
      auto it = std::find_if(
          reduced.begin(), reduced.end(),
          [&keyVal](const KeyVal &kv) { return kv.key == keyVal.key; });
      if (it != reduced.end()) {
        it->val += keyVal.val;
      } else {
        reduced.push_back(keyVal);
      }
    }
  }
  return reduced;
}
} // namespace mapReduce